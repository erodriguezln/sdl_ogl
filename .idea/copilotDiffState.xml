<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/opengl_sdl_guide.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/opengl_sdl_guide.md" />
              <option name="updatedContent" value="# Guía de OpenGL con SDL&#10;&#10;## Introducción&#10;&#10;Este proyecto integra **SDL3** (Simple DirectMedia Layer) con **OpenGL** para crear aplicaciones gráficas 3D. SDL maneja la ventana y eventos, mientras OpenGL se encarga del renderizado.&#10;&#10;## Arquitectura del Programa&#10;&#10;### 1. Sistema de Callbacks de SDL3&#10;&#10;SDL3 usa un sistema de callbacks en lugar del `main()` tradicional:&#10;&#10;- `SDL_AppInit()`: Inicialización única&#10;- `SDL_AppEvent()`: Manejo de eventos&#10;- `SDL_AppIterate()`: Bucle de renderizado&#10;- `SDL_AppQuit()`: Limpieza de recursos&#10;&#10;### 2. Pipeline de Inicialización&#10;&#10;#### Configuración del Contexto OpenGL&#10;```cpp&#10;SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);   // Buffer de profundidad&#10;SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);  // Double buffering&#10;```&#10;&#10;#### Creación de Ventana y Contexto&#10;1. **Ventana SDL**: Contenedor para el contenido gráfico&#10;2. **Contexto OpenGL**: Enlace entre SDL y OpenGL&#10;3. **GLAD**: Carga funciones OpenGL modernas dinámicamente&#10;&#10;### 3. Objetos OpenGL Fundamentales&#10;&#10;#### VAO (Vertex Array Object)&#10;- **Propósito**: Almacena la configuración de cómo interpretar los vértices&#10;- **Función**: Guarda punteros a VBOs y layout de atributos&#10;- **Ventaja**: Permite cambiar configuraciones rápidamente&#10;&#10;#### VBO (Vertex Buffer Object)&#10;- **Propósito**: Buffer en GPU que contiene datos de vértices&#10;- **Contenido**: Coordenadas, colores, normales, coordenadas UV&#10;- **Tipo**: `GL_STATIC_DRAW` para datos que no cambian&#10;&#10;#### Layout de Vértices&#10;```cpp&#10;// Cada vértice: X, Y, Z, U, V (posición + coordenadas de textura)&#10;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);&#10;```&#10;&#10;## Conceptos Clave&#10;&#10;### Double Buffering&#10;- **Front Buffer**: Se muestra en pantalla&#10;- **Back Buffer**: Se renderiza el siguiente frame&#10;- **Intercambio**: `SDL_GL_SwapWindow()` intercambia buffers&#10;&#10;### Depth Testing&#10;```cpp&#10;glEnable(GL_DEPTH_TEST);  // Habilita Z-buffer&#10;```&#10;- Determina qué píxeles están al frente&#10;- Esencial para renderizado 3D correcto&#10;&#10;### Bucle de Renderizado&#10;1. **Limpiar**: `glClear()` - Preparar buffers&#10;2. **Configurar**: `glBindVertexArray()` - Activar geometría&#10;3. **Dibujar**: `glDrawArrays()` - Renderizar primitivas&#10;4. **Presentar**: `SDL_GL_SwapWindow()` - Mostrar resultado&#10;&#10;## Geometría del Cubo&#10;&#10;### Estructura de Datos&#10;- **36 vértices** (6 caras × 2 triángulos × 3 vértices)&#10;- **Cada vértice**: 5 valores (X, Y, Z, U, V)&#10;- **Coordenadas UV**: Para mapeo de texturas futuro&#10;&#10;### Orden de Vértices&#10;- **Sentido horario**: Define cara frontal&#10;- **Winding order**: Importante para face culling&#10;&#10;## Flujo de Ejecución&#10;&#10;1. **Inicialización**:&#10;   - Configurar SDL y OpenGL&#10;   - Crear buffers y cargar geometría&#10;   - Configurar pipeline de renderizado&#10;&#10;2. **Bucle Principal**:&#10;   - Procesar eventos (cerrar ventana, input)&#10;   - Renderizar frame actual&#10;   - Intercambiar buffers&#10;&#10;3. **Limpieza**:&#10;   - Liberar recursos OpenGL&#10;   - Destruir ventana SDL&#10;   - Cerrar SDL&#10;&#10;## Próximos Pasos&#10;&#10;### Shaders&#10;- **Vertex Shader**: Procesa cada vértice&#10;- **Fragment Shader**: Determina color de cada píxel&#10;- **Shader Program**: Enlaza vertex y fragment shaders&#10;&#10;### Transformaciones&#10;- **Model Matrix**: Posición/rotación del objeto&#10;- **View Matrix**: Posición/orientación de cámara&#10;- **Projection Matrix**: Perspectiva 3D&#10;&#10;### Texturas&#10;- Cargar imágenes desde archivos&#10;- Aplicar texturas a geometría&#10;- Coordenadas UV para mapeo&#10;&#10;## Herramientas y Librerías&#10;&#10;- **SDL3**: Ventana, contexto, eventos&#10;- **GLAD**: Carga de funciones OpenGL&#10;- **GLM**: Matemáticas 3D (vectores, matrices)&#10;- **OpenGL**: API de renderizado&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="#define SDL_MAIN_USE_CALLBACKS 1&#10;&#10;#include &lt;SDL3/SDL.h&gt;&#10;#include &lt;SDL3/SDL_main.h&gt;&#10;#include &lt;SDL3/SDL_mouse.h&gt;&#10;#include &lt;glad/glad.h&gt;&#10;#include &lt;glm.hpp&gt;&#10;#include &lt;gtc/matrix_transform.hpp&gt;&#10;#include &lt;gtc/type_ptr.hpp&gt;&#10;&#10;static SDL_Window *window = nullptr;&#10;static SDL_GLContext context = nullptr;&#10;// static SDL_Renderer *renderer = nullptr;&#10;&#10;#define WINDOW_WIDTH 800&#10;#define WINDOW_HEIGHT 600&#10;&#10;typedef struct AppState {&#10;    unsigned int VBO, VAO;&#10;} AppState;&#10;&#10;SDL_AppResult SDL_AppInit(void **appstate, int argc, char *argv[]) {&#10;&#10;    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);&#10;    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);&#10;    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);&#10;    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);&#10;    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);&#10;&#10;    window = SDL_CreateWindow(&quot;SDL OpenGL&quot;, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_OPENGL);&#10;    if (!window) {&#10;        SDL_Log(&quot;Couldn't create window: %s&quot;, SDL_GetError());&#10;        return SDL_APP_FAILURE;&#10;    }&#10;&#10;    context = SDL_GL_CreateContext(window);&#10;    if (!context) {&#10;        SDL_Log(&quot;Couldn't create OpenGL context: %s&quot;, SDL_GetError());&#10;        return SDL_APP_FAILURE;&#10;    }&#10;&#10;    if (!gladLoadGLLoader((GLADloadproc) SDL_GL_GetProcAddress)) {&#10;        SDL_Log(&quot;Couldn't load GLAD function: %s&quot;, SDL_GetError());&#10;        return SDL_APP_FAILURE;&#10;    }&#10;&#10;    AppState *state = new AppState;&#10;    state-&gt;VAO = 0;&#10;&#10;    glEnable(GL_DEPTH_TEST);&#10;&#10;    // cube&#10;    float vertices[] = {&#10;        // Cara frontal&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        0.5f, -0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 1.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 1.0f,&#10;        -0.5f, 0.5f, 0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;&#10;        // Cara trasera&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 0.0f,&#10;        0.5f, -0.5f, -0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        -0.5f, 0.5f, -0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 0.0f,&#10;&#10;        // Cara izquierda&#10;        -0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        -0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        -0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;&#10;        // Cara derecha&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;&#10;        // Cara inferior&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, -0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, -0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, -0.5f, 0.5f, 1.0f, 0.0f,&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;&#10;        // Cara superior&#10;        -0.5f, 0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        -0.5f, 0.5f, 0.5f, 0.0f, 0.0f,&#10;        -0.5f, 0.5f, -0.5f, 0.0f, 1.0f&#10;    };&#10;&#10;    glm::vec3 cubePosition = glm::vec3(0.0f, 0.0f, 0.0f);&#10;&#10;    // TODO entender bien porque uso &amp; o nada&#10;    glGenVertexArrays(1, &amp;state-&gt;VAO); // Generate Vertex Array Object&#10;    glGenBuffers(1, &amp;state-&gt;VBO); // Generate Vertex Buffer Object&#10;&#10;    glBindVertexArray(state-&gt;VAO); // Bind the Vertex Array Object&#10;&#10;    glBindBuffer(GL_ARRAY_BUFFER, state-&gt;VBO); // Bind the Vertex Buffer Object&#10;    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // Copy the vertex data into the buffer&#10;&#10;    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void *) 0);&#10;    glEnableVertexAttribArray(0); // Enable the vertex attribute&#10;&#10;    *appstate = state;&#10;&#10;    return SDL_APP_CONTINUE;&#10;}&#10;&#10;SDL_AppResult SDL_AppEvent(void *appstate, SDL_Event *event) {&#10;    AppState *state = (AppState *) appstate;&#10;&#10;    if (event-&gt;type == SDL_EVENT_QUIT) {&#10;        return SDL_APP_SUCCESS;&#10;    }&#10;&#10;&#10;    return SDL_APP_CONTINUE;&#10;}&#10;&#10;SDL_AppResult SDL_AppIterate(void *appstate) {&#10;    AppState *state = (AppState *) appstate;&#10;&#10;    // Render&#10;    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);&#10;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);&#10;&#10;    glBindVertexArray(state-&gt;VAO);&#10;&#10;    glDrawArrays(GL_TRIANGLES, 0, 36);&#10;&#10;&#10;    SDL_GL_SwapWindow(window);&#10;&#10;    return SDL_APP_CONTINUE;&#10;}&#10;&#10;void SDL_AppQuit(void *appstate, SDL_AppResult result) {&#10;    AppState *state = (AppState *) appstate;&#10;&#10;    SDL_DestroyWindow(window);&#10;    SDL_Quit();&#10;}" />
              <option name="updatedContent" value="#define SDL_MAIN_USE_CALLBACKS 1  // Usar callbacks de SDL3 en lugar de main tradicional&#10;&#10;#include &lt;SDL3/SDL.h&gt;&#10;#include &lt;SDL3/SDL_main.h&gt;&#10;#include &lt;SDL3/SDL_mouse.h&gt;&#10;#include &lt;glad/glad.h&gt;      // Loader para funciones OpenGL modernas&#10;#include &lt;glm.hpp&gt;          // Matemáticas 3D&#10;#include &lt;gtc/matrix_transform.hpp&gt;&#10;#include &lt;gtc/type_ptr.hpp&gt;&#10;&#10;// Variables globales para ventana y contexto OpenGL&#10;static SDL_Window *window = nullptr;&#10;static SDL_GLContext context = nullptr;&#10;&#10;#define WINDOW_WIDTH 800&#10;#define WINDOW_HEIGHT 600&#10;&#10;// Estado de la aplicación - contiene datos OpenGL&#10;typedef struct AppState {&#10;    unsigned int VBO, VAO;  // Vertex Buffer Object y Vertex Array Object&#10;} AppState;&#10;&#10;// INICIALIZACIÓN: Se ejecuta una vez al inicio&#10;SDL_AppResult SDL_AppInit(void **appstate, int argc, char *argv[]) {&#10;    // Configurar atributos del contexto OpenGL antes de crearlo&#10;    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);      // 8 bits para canal rojo&#10;    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);    // 8 bits para canal verde&#10;    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);     // 8 bits para canal azul&#10;    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);   // 24 bits para depth buffer&#10;    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);  // Habilitar double buffering&#10;&#10;    // Crear ventana con soporte OpenGL&#10;    window = SDL_CreateWindow(&quot;SDL OpenGL&quot;, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_OPENGL);&#10;    if (!window) {&#10;        SDL_Log(&quot;Couldn't create window: %s&quot;, SDL_GetError());&#10;        return SDL_APP_FAILURE;&#10;    }&#10;&#10;    // Crear contexto OpenGL asociado a la ventana&#10;    context = SDL_GL_CreateContext(window);&#10;    if (!context) {&#10;        SDL_Log(&quot;Couldn't create OpenGL context: %s&quot;, SDL_GetError());&#10;        return SDL_APP_FAILURE;&#10;    }&#10;&#10;    // Cargar funciones OpenGL modernas usando GLAD&#10;    if (!gladLoadGLLoader((GLADloadproc) SDL_GL_GetProcAddress)) {&#10;        SDL_Log(&quot;Couldn't load GLAD function: %s&quot;, SDL_GetError());&#10;        return SDL_APP_FAILURE;&#10;    }&#10;&#10;    // Inicializar estado de la aplicación&#10;    AppState *state = new AppState;&#10;    state-&gt;VAO = 0;&#10;&#10;    // Habilitar test de profundidad para 3D correcto&#10;    glEnable(GL_DEPTH_TEST);&#10;&#10;    // Definir vértices del cubo (posición XYZ + coordenadas UV)&#10;    // Cada cara está formada por 2 triángulos (6 vértices)&#10;    float vertices[] = {&#10;        // Cara frontal&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        0.5f, -0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 1.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 1.0f,&#10;        -0.5f, 0.5f, 0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;&#10;        // Cara trasera&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 0.0f,&#10;        0.5f, -0.5f, -0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        -0.5f, 0.5f, -0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 0.0f,&#10;&#10;        // Cara izquierda&#10;        -0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        -0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        -0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;&#10;        // Cara derecha&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;&#10;        // Cara inferior&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, -0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, -0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, -0.5f, 0.5f, 1.0f, 0.0f,&#10;        -0.5f, -0.5f, 0.5f, 0.0f, 0.0f,&#10;        -0.5f, -0.5f, -0.5f, 0.0f, 1.0f,&#10;&#10;        // Cara superior&#10;        -0.5f, 0.5f, -0.5f, 0.0f, 1.0f,&#10;        0.5f, 0.5f, -0.5f, 1.0f, 1.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        0.5f, 0.5f, 0.5f, 1.0f, 0.0f,&#10;        -0.5f, 0.5f, 0.5f, 0.0f, 0.0f,&#10;        -0.5f, 0.5f, -0.5f, 0.0f, 1.0f&#10;    };&#10;&#10;    glm::vec3 cubePosition = glm::vec3(0.0f, 0.0f, 0.0f);  // Posición del cubo&#10;&#10;    // CONFIGURACIÓN DE BUFFERS OPENGL:&#10;    glGenVertexArrays(1, &amp;state-&gt;VAO); // Generar VAO (guarda configuración de vértices)&#10;    glGenBuffers(1, &amp;state-&gt;VBO);      // Generar VBO (buffer para datos de vértices)&#10;&#10;    glBindVertexArray(state-&gt;VAO);     // Activar VAO para configurar&#10;&#10;    glBindBuffer(GL_ARRAY_BUFFER, state-&gt;VBO);  // Activar VBO como buffer de vértices&#10;    // Copiar datos de vértices al buffer en GPU&#10;    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#10;&#10;    // Configurar layout de vértices: posición (3 floats) en índice 0&#10;    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void *) 0);&#10;    glEnableVertexAttribArray(0); // Habilitar atributo de posición&#10;&#10;    *appstate = state;  // Pasar estado a SDL&#10;&#10;    return SDL_APP_CONTINUE;&#10;}&#10;&#10;// EVENTOS: Se ejecuta cuando hay eventos (teclado, mouse, etc.)&#10;SDL_AppResult SDL_AppEvent(void *appstate, SDL_Event *event) {&#10;    AppState *state = (AppState *) appstate;&#10;&#10;    // Manejar cierre de ventana&#10;    if (event-&gt;type == SDL_EVENT_QUIT) {&#10;        return SDL_APP_SUCCESS;  // Terminar aplicación limpiamente&#10;    }&#10;&#10;    return SDL_APP_CONTINUE;&#10;}&#10;&#10;// BUCLE PRINCIPAL: Se ejecuta cada frame para renderizar&#10;SDL_AppResult SDL_AppIterate(void *appstate) {&#10;    AppState *state = (AppState *) appstate;&#10;&#10;    // RENDERIZADO:&#10;    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);  // Color de fondo (gris-azulado)&#10;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // Limpiar buffers&#10;&#10;    glBindVertexArray(state-&gt;VAO);  // Activar configuración de vértices&#10;&#10;    glDrawArrays(GL_TRIANGLES, 0, 36);  // Dibujar 36 vértices como triángulos (12 triángulos = 6 caras)&#10;&#10;    SDL_GL_SwapWindow(window);  // Intercambiar buffers (mostrar frame renderizado)&#10;&#10;    return SDL_APP_CONTINUE;&#10;}&#10;&#10;// LIMPIEZA: Se ejecuta al cerrar la aplicación&#10;void SDL_AppQuit(void *appstate, SDL_AppResult result) {&#10;    AppState *state = (AppState *) appstate;&#10;&#10;    // Liberar recursos&#10;    SDL_DestroyWindow(window);  // Destruir ventana&#10;    SDL_Quit();                 // Limpiar SDL&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>